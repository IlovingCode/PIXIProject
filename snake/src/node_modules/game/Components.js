export class MoveComponent {
    constructor(target) {
        this.position = target.position;
        this.v = target.v;
        this.a = target.a;
    }

    update(dt) {
        if (this.v.x != 0) {
            this.v.x += this.a.x * dt;
            this.position.x += this.v.x * dt;
        }

        if (this.v.y != 0) {
            this.v.y += this.a.y * dt;
            this.position.y += this.v.y * dt;
        }
    }
}

export class SnakeController {
    constructor(target) {
        this.target = target;
        this.delta = 0;
        this.speed = 0;
        this.turnLeft = false;
    }

    scale(scale) {
        this.delta *= scale;
        this.speed *= scale;
    }

    update(dt) {
        if (this.turnLeft) {
            this.target.rotation -= this.delta * dt;
        } else {
            this.target.rotation += this.delta * dt;
        }

        const angle = this.target.rotation - Math.PI / 2;
        this.target.v.set(Math.cos(angle) * this.speed, Math.sin(angle) * this.speed);
    }
}

export class AutoComponent {
    constructor(target) {
        this.target = target.sprite;
        this.control = target.control;
        this.rotation = 0;
        this.delta = Math.PI / 3;
    }

    setPath(path) {
        this.path = path;
        this.pathId = 0;
        this.updateDest();
    }

    updateDest() {
        this.dest = this.path[this.pathId++].sprite.position;

        if (this.pathId >= this.path.length)
            this.pathId = 0;
    }

    update(dt) {
        const x = this.dest.x - this.target.position.x;
        const y = this.dest.y - this.target.position.y;
        this.rotation = Math.atan2(x, -y);
        const r = this.target.width / 2;

        if (x * x + y * y < r * r)
            this.updateDest();

        if (this.control.turnLeft) {
            if (this.target.rotation < this.rotation - this.delta)
                this.control.turnLeft = false;
        } else {
            if (this.target.rotation > this.rotation + this.delta)
                this.control.turnLeft = true;
        }
    }
}

export class ScoreComponent {
    constructor() {
        this.text = document.getElementById("Score");
        this.setScore(0);
    }

    setScore(score) {
        this.score = score;
        this.text.innerHTML = score.toString();
    }
}

export class CircleCollider {
    constructor(sprite, target, callback) {
        this.sprite = sprite;
        this.target = target;
    }

    update(dt) {
        const x = this.target.position.x - this.sprite.position.x;
        const y = this.target.position.y - this.sprite.position.y;
        const r = (this.target.width + this.sprite.width) / 2;

        if (x * x + y * y < r * r)
            callback();
    }
}

export class CheckOutOfBound {
    constructor(sprite, target, callback) {
        this.sprite = sprite;
        this.target = target;
    }

    update(dt) {
        const x = this.target.position.x - this.sprite.position.x;
        const y = this.target.position.y - this.sprite.position.y;
        const r = (this.target.width + this.sprite.width) / 2;

        if (x * x + y * y < r * r)
            callback();
    }
}