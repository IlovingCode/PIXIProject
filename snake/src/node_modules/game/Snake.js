import { Point, Sprite, Container } from 'pixi.js';
import { ScoreComponent, MoveComponent, SnakeController, AutoComponent } from 'game/Components';
import * as input from 'engine/input';

const createSprite = function(id, container) {
    const sprite = Sprite.fromFrame(id);
    sprite.anchor.set(0.5, 0.5);
    container.addChild(sprite);
    return sprite;
};

export class Head {
    constructor(pos, container) {
        this.container = new Container;
        container.addChild(this.container);

        this.sprite = createSprite("head", container);
        this.sprite.scale.set(0.4, 0.4);
        this.sprite.v = new Point;
        this.sprite.a = new Point;

        this.scale = new Point;
        this.child = new Body(this.sprite);

        this.score = new ScoreComponent;
        this.move = new MoveComponent(this.sprite);
        this.control = new SnakeController(this.sprite);

        this.reset(pos);
    }

    addChild() {
        this.control.scale(1.05);
        this.scale.set(this.scale.x + 0.01, this.scale.y + 0.01);
        this.score.setScore(this.score.score + 1);

        for (let i = 0; i < 5; i++) {
            const currentChild = this.child;
            this.child = new Body(this.sprite);

            this.child.child = currentChild;
            currentChild.parent = this.child;

            if (i == 0) {
                this.child.sprite = createSprite("body", this.container);
                this.child.sprite.scale.copy(this.scale);
            }
        }
    }

    reset(pos) {
        this.child.destroy(this);

        this.sprite.position.copy(pos);
        this.sprite.rotation = 0;
        this.control.speed = 70;
        this.control.delta = Math.PI * 0.8;
        this.score.score = -2;
        this.scale.set(0.2, 0.2);

        this.addChild();
        this.addChild();
    }

    update(dt) {
        this.child.update(dt);

        /*if (input.buttonReleased("ControlLeft")) {
            this.addChild();
        }*/

        if (input.buttonReleased("Space")) {
            this.control.turnLeft = !this.control.turnLeft;
        }

        this.move.update(dt);
        this.control.update(dt);
    }
}

export class FakeHead {
    constructor(pos, container) {
        this.container = new Container;
        container.addChild(this.container);

        this.sprite = createSprite("head1", container);
        this.sprite.scale.set(0.4, 0.4);
        this.sprite.v = new Point;
        this.sprite.a = new Point;

        this.scale = new Point;
        this.child = new Body(this.sprite);
        this.spriteList = [];
        this.spriteList.push(this.sprite);

        this.move = new MoveComponent(this.sprite);
        this.control = new SnakeController(this.sprite);
        this.auto = new AutoComponent(this);

        this.reset(pos);
    }

    addChild() {
        this.control.scale(1.05);
        this.scale.set(this.scale.x + 0.01, this.scale.y + 0.01);

        for (let i = 0; i < 5; i++) {
            const currentChild = this.child;
            this.child = new Body(this.sprite);

            this.child.child = currentChild;
            currentChild.parent = this.child;

            if (i == 0) {
                this.child.sprite = createSprite("body1", this.container);
                this.spriteList.push(this.child.sprite);
                this.child.sprite.scale.copy(this.scale);
            }
        }
    }

    reset(pos) {
        this.child.destroy(this);

        this.sprite.position.copy(pos);
        this.sprite.rotation = 0;
        this.control.speed = 50;
        this.control.delta = Math.PI * 1.5;
        this.scale.set(0.2, 0.2);

        this.addChild();
        this.addChild();
        this.addChild();
        this.addChild();
        this.addChild();
        this.addChild();
    }

    checkHit(target) {

        for (let i = 0; i < this.spriteList.length; i++) {
            const e = this.spriteList[i];

            const x = target.position.x - e.position.x;
            const y = target.position.y - e.position.y;
            const r = (target.width + e.width) / 2;

            if (x * x + y * y < r * r) {
                return true;
            }
        }
        return false;
    }

    update(dt) {
        this.child.update(dt);
        this.move.update(dt);
        this.control.update(dt);
        this.auto.update(dt);
    }
}

export class Body {
    constructor(parent) {
        this.parent = parent;
        this.child = null;
        this.position = new Point;
        this.position.copy(parent.position);
    }

    destroy(head) {
        this.child && this.child.destroy(head);

        this.sprite && head.container.removeChild(this.sprite);
        this.sprite = null;
        this.child = null;
    }

    update(dt) {
        this.child && this.child.update(dt);
        this.position.copy(this.parent.position);
        this.sprite && this.sprite.position.copy(this.position);
    }
}

export class Food {
    constructor(container, getPos, snake) {
        this.sprite = createSprite("food", container);
        this.getPos = getPos;
        this.getPos(this.sprite.position);
        this.sprite.scale.set(0.2, 0.2);
        this.snake = snake;
        this.distance = new Point;
        this.threshold = this.sprite.width / 2 + snake.sprite.width / 2;
        this.threshold *= this.threshold;
    }

    update(dt) {
        this.distance.set(
            this.snake.sprite.position.x - this.sprite.position.x,
            this.snake.sprite.position.y - this.sprite.position.y
        );

        if (this.distance.x * this.distance.x + this.distance.y * this.distance.y < this.threshold) {
            this.getPos(this.sprite.position);
            this.snake.addChild();
        }
    }
}