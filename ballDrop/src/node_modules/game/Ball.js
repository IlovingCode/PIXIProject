import { Point, Sprite, Text } from 'pixi.js';
import * as input from 'engine/input';
import { Rect } from 'texture-atlas';

export const createSprite = function(id, container) {
    const sprite = Sprite.fromFrame(id);
    sprite.anchor.set(0.5, 0.5);
    container.addChild(sprite);
    return sprite;
};

export const checkBound = function(bound, target) {
    const x = target.width * 0.5;
    const y = target.height * 0.5;
    if (target.position.x < bound.x + x
        || target.position.x > bound.width - x) {
        target.v.x = -target.v.x;
        target.a.x = -target.a.x;
        return true;
    }

    return false;
};

export const checkHit = function(s1, s2) {
    const r = (s1.width + s2.width) / 2;
    const x = s1.position.x + s1.width * (s1.anchor.x - 0.5)
        - s2.position.x - s2.width * (s2.anchor.x - 0.5);
    const y = s1.position.y + s1.height * (s1.anchor.y - 0.5)
        - s2.position.y - s2.height * (s2.anchor.y - 0.5);

    return x * x + y * y < r * r;
};

export class Soldier {
    constructor(pos, container) {
        this.sprite = createSprite("enemy", container);
        this.sprite.scale.set(0.42, 0.42);
        this.sprite.tint = 0x000000;
        this.sprite.position.copy(pos);
        this.sprite.v = new Point;
        this.sprite.a = new Point;

        this.sprite.v.y = 10;
        this.sprite.a.y = 50;

        this.comp = [];
        this.comp.push(new RollComponent(this.sprite));
        this.comp.push(new MoveComponent(this.sprite));
    }

    update(dt) {
        this.comp.forEach(function(element) {
            element.update(dt);
        });

        if (input.buttonPressed("Space")) {
            this.comp.forEach(function(element) {
                element.start();
            });
        }
    }

    onHit(target) {
        const x = this.sprite.position.x - target.position.x;
        const y = this.sprite.position.y - target.position.y;
        const rot = Math.atan2(y, x);

        const r = (this.sprite.width + target.width) / 2;
        this.sprite.position.set(target.position.x + r * Math.cos(rot),
            target.position.y + r * Math.sin(rot));

        this.sprite.v.y += 3 * Math.sin(rot);
        this.sprite.v.x += 10 * Math.cos(rot);
    }
}

export class MoveComponent {
    constructor(target) {
        this.position = target.position;
        this.v = target.v;
        this.a = target.a;
    }

    start() {
    }

    update(dt) {
        if (this.v.x != 0) {
            this.v.x += this.a.x * dt;
            this.position.x += this.v.x * dt;
        }

        if (this.v.y != 0) {
            this.v.y += this.a.y * dt;
            this.position.y += this.v.y * dt;
        }
    }
}

export class RollComponent {
    constructor(target) {
        this.target = target;
        this.rot0 = this.target.rotation;
        this.v = 0;
    }

    start() {
    }

    update(dt) {
        if (this.v == 0)
            return;

        this.target.rotation += this.v * dt;
    }
}