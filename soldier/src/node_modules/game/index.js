import 'game/style.css'; // webpack magic
//import {FBInstant} from 'mock/fbinstant.6.0.mock.js'
import { Point, SCALE_MODES, settings, Rectangle, Graphics } from 'pixi.js';
settings.SCALE_MODE = SCALE_MODES.LINEAR;

import * as engine from 'engine';
import * as display from 'engine/display';
import Scene from 'engine/Scene';
import { Soldier } from 'game/Soldier';
import { Map } from 'game/Map';

const removeSpriteElement = function(list, id, container) {
  const e = list[id];
  container.removeChild(e.sprite);
  e.sprite = null;
  list.splice(id, 1);
};

class TestScene extends Scene {
  init() {
    this.backgroundColor = 0xEEEEEE;

    const ele = document.getElementById("Root");
    ele.style.width = display.width;
    ele.style.height = display.height;

    const delta = 100;
    this.bound = new Rectangle(-delta, -delta,
      display.width + delta * 2, display.height + delta * 2);

    const center = new Point(display.width * 0.3, display.height * 0.8);
    this.character = new Soldier(center, this.stage);

    this.bullet = this.character.comp[3].pool;
    this.map = new Map(display.width, display.height);
    this.enemy = this.map.spawnEnemy(this.stage);

    this.text = document.getElementById("Score");
    this.setScore(0);

    this.g = new Graphics();
    this.stage.addChild(this.g);
  }

  setScore(score) {
    this.score = score;
    this.text.innerHTML = score.toString();
  }

  killEnemy(id) {
    removeSpriteElement(this.enemy, id, this.stage);
    if (this.enemy.length == 0)
      setTimeout(() => {
        this.enemy = this.map.spawnEnemy(this.stage);
      }, 0.5);
  }

  drawTrajectory() {
    const rot = this.character.sprite.rotation - Math.PI / 2;
    const direction = new Point(Math.cos(rot), Math.sin(rot));
    const begin = this.character.sprite.position;

    this.g.clear();
    this.g.beginFill();
    this.g.lineStyle(1, 0xFF00FF, 0.25);
    this.g.moveTo(begin.x, begin.y);
    this.g.lineTo(begin.x + direction.x * 1000,
      begin.y + direction.y * 1000);
    this.g.endFill();
  }

  update(dt) {
    if (!this.character.sprite.onGround) {
      //dt *= 0.8;
    }

    this.character.update(dt);
    this.drawTrajectory();

    for (let i = this.enemy.length - 1; i >= 0; i--) {
      const e = this.enemy[i];
      e.update(dt);

      if (!this.bound.contains(e.sprite.position.x, e.sprite.position.y))
        this.killEnemy(i);
    }

    for (let i = this.bullet.length - 1; i >= 0; i--) {
      const b = this.bullet[i].sprite;

      if (!this.bound.contains(b.position.x, b.position.y)) {
        removeSpriteElement(this.bullet, i, this.stage);
      }

      for (let j = this.enemy.length - 1; j >= 0; j--) {
        const e = this.enemy[j].sprite;
        const r = (e.width + b.width) * 0.5;
        const x = e.position.x - b.position.x;
        const y = e.position.y - b.position.y;

        if (x * x + y * y < r * r) {
          this.setScore(this.score + 1);
          this.killEnemy(j);
        }
      }
    }
  }
}

const USE_FB_INSTANT = false;
const scene = new TestScene;

window.addEventListener('touchstart', function() {
  // the user touched the screen!
});

window.startGame = function() {
  const parentElement = document.getElementById("Root");
  engine.launch(scene, { parentElement });
};

window.postScore = function(score) {
  window.FBInstant.getLeaderboardAsync('Happy Worm.' + window.FBInstant.context.getID())
    .then((leaderboard) => {
      return leaderboard.setScoreAsync(score);
    })
    .then(() => {
      window.FBInstant.updateAsync({
        action: 'LEADERBOARD',
        name: 'Happy Worm.' + window.FBInstant.context.getID(),
      });
    });
};

window.onload = function() {
  if (USE_FB_INSTANT) {
    window.FBInstant.initializeAsync()
      .then(function() {
        // Start loading game assets here
        window.FBInstant.startGameAsync()
          .then(function() {
            window.startGame();
          });
      });
  } else {
    window.startGame();
  }
};