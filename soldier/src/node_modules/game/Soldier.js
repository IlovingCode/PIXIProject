import { Point, Sprite } from 'pixi.js';
import * as input from 'engine/input';

export const createSprite = function(id, container) {
    const sprite = Sprite.fromFrame(id);
    sprite.anchor.set(0.5, 0.5);
    container.addChild(sprite);
    return sprite;
};

export class Soldier {
    constructor(pos, container) {
        this.sprite = createSprite("soldier", container);
        this.sprite.scale.set(0.5, 0.5);
        this.sprite.position.copy(pos);
        this.sprite.v = new Point;
        this.sprite.a = new Point;
        this.sprite.onGround = true;

        this.comp = [];
        this.comp.push(new RollComponent(this.sprite));
        this.comp.push(new MoveComponent(this.sprite));
        this.comp.push(new ForceComponent(this.sprite));
        this.comp.push(new FireComponent(this.sprite, container));
        this.comp.push(new JumpComponent(this.sprite));
    }

    update(dt) {
        this.comp.forEach(function(element) {
            element.update(dt);
        });

        if (input.buttonPressed("Space")) {
            this.comp.forEach(function(element) {
                element.start();
            });
        }
    }
}

export class JumpComponent {
    constructor(target) {
        this.target = target;
        this.position = target.position;
        this.y0 = this.position.y;
        this.v = target.v;
        this.a = target.a;
    }

    start() {
        if (!this.target.onGround)
            return;

        this.target.onGround = false;
        this.v.y = -500;
        this.a.y = Math.abs(this.v.y) * 2;
    }

    update(dt) {
        if (this.v.x * this.a.x > 0)
            this.v.x = 0;

        if (!this.target.onGround) {
            if (this.position.y > this.y0) {
                this.v.y = 0;
                this.position.y = this.y0;
                this.target.onGround = true;
            }
        }
    }
}

export class MoveComponent {
    constructor(target) {
        this.position = target.position;
        this.v = target.v;
        this.a = target.a;
    }

    start() {
    }

    update(dt) {
        if (this.v.x != 0) {
            this.v.x += this.a.x * dt;
            this.position.x += this.v.x * dt;
        }

        if (this.v.y != 0) {
            this.v.y += this.a.y * dt;
            this.position.y += this.v.y * dt;
        }
    }
}

export class ForceComponent {
    constructor(target) {
        this.target = target;
        this.v = target.v;
        this.a = target.a;
    }

    start() {
        if (this.target.onGround)
            return;

        this.v.y += 500 * Math.sin(this.target.rotation + Math.PI / 2);
        this.v.x = 200 * Math.cos(this.target.rotation + Math.PI / 2);

        //this.a.y = Math.abs(this.v.y) * 2.5;
        this.a.x = -this.v.x * 1.5;
    }

    update(dt) {
        if (this.target.position.x < this.target.width * 0.5) {
            this.target.position.x = this.target.width * 0.5;
            this.v.x = -this.v.x;
            this.a.x = -this.a.x;
        }
    }
}

export class RollComponent {
    constructor(target) {
        this.target = target;
        this.rot0 = this.target.rotation;
        this.v = 0;
    }

    start() {
        if (!this.target.onGround)
            return;

        this.v = Math.PI * 1.5;

        /*const sin = Math.sin(this.target.rotation);
        const cos = Math.cos(this.target.rotation);
        if (Math.abs(sin) < Math.abs(cos)) {
            if (cos * sin < 0)
                this.v = -this.v;
        } else {
            if (cos * sin > 0)
                this.v = -this.v;
        }*/
    }

    update(dt) {
        if (this.v == 0)
            return;

        this.target.rotation += this.v * dt;

        if (this.target.onGround) {
            this.v = 0;
            this.target.rotation = this.rot0;
        }
    }
}

export class FireComponent {
    constructor(target, container) {
        this.target = target;
        this.container = container;
        this.pool = [];
    }

    start() {
        if (!this.target.onGround)
            this.pool.push(new Bullet(this.target, this.container));
    }

    update(dt) {
        this.pool.forEach(function(element) {
            element.update(dt);
        });
    }
}

export class TrackingCameraComponent {
    constructor(target, camera) {
        this.target = target;
        this.camera = camera;
        this.speed = new Point(1, 1);
    }

    start() {
    }

    update(dt) {
        this.camera.pivot.x += (target.x - this.cam.pivot.x) * this.speed.x * dt;
        this.camera.pivot.y += (target.y - this.cam.pivot.y) * this.speed.y * dt;
    }
}

export class Bullet {
    constructor(target, container) {
        this.sprite = createSprite("bullet", container);
        this.sprite.scale.set(0.1, 0.1);

        const rot = target.rotation + Math.PI / 2;
        const d = new Point(Math.cos(rot), Math.sin(rot));

        this.sprite.position.set(
            target.position.x - d.x * target.width / 2,
            target.position.y - d.y * target.width / 2,
        );

        const spd = 500;
        this.sprite.v = new Point(-d.x * spd, -d.y * spd);
        this.sprite.a = new Point;

        this.comp = new MoveComponent(this.sprite);
    }

    update(dt) {
        this.comp.update(dt);
    }
}

export class Enemy {
    constructor(pos, container) {
        this.sprite = createSprite("enemy", container);
        this.sprite.scale.set(0.5, 0.5);
        this.sprite.position.copy(pos);
        //this.pos0 = pos;

        this.sprite.v = new Point;
        this.sprite.a = new Point;

        this.comp = new MoveComponent(this.sprite);
    }

    update(dt) {
        this.comp.update(dt);
    }
}